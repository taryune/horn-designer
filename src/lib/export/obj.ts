/**
 * OBJ Export for Waveguide Meshes
 * ================================
 *
 * Exports mesh data to Wavefront OBJ format for 3D applications.
 */

import type { MeshData } from '../types/waveguide'

/**
 * Normalize a 3D vector.
 */
function normalize(x: number, y: number, z: number): [number, number, number] {
  const len = Math.sqrt(x * x + y * y + z * z)
  if (len < 1e-10) return [0, 0, 1] // Fallback for zero-length vectors
  return [x / len, y / len, z / len]
}

/**
 * Calculate vertex normals for smooth shading.
 *
 * For each vertex, we average the normals of all adjacent quad faces.
 * This produces smooth normals suitable for continuous surfaces like horns.
 *
 * @param meshData - Generated mesh data
 * @returns Array of normals [nx, ny, nz] for each vertex
 */
function calculateVertexNormals(meshData: MeshData): [number, number, number][] {
  const { rings, numSlices } = meshData
  const vertsPerRing = numSlices + 1
  const totalVerts = rings.length * vertsPerRing

  // Initialize normal accumulator for each vertex
  const normals: [number, number, number][] = Array(totalVerts)
    .fill(null)
    .map(() => [0, 0, 0])

  // Process each quad face and accumulate normals
  for (let ri = 0; ri < rings.length - 1; ri++) {
    for (let si = 0; si < numSlices; si++) {
      // Get the four vertices of this quad (counter-clockwise)
      const a = ri * vertsPerRing + si
      const b = ri * vertsPerRing + si + 1
      const c = (ri + 1) * vertsPerRing + si + 1
      const d = (ri + 1) * vertsPerRing + si

      const vA = rings[ri].ring[si]
      const vB = rings[ri].ring[si + 1]
      const vD = rings[ri + 1].ring[si]

      // Calculate two edge vectors from the quad
      // Edge 1: A → B
      const e1x = vB[0] - vA[0]
      const e1y = vB[1] - vA[1]
      const e1z = vB[2] - vA[2]

      // Edge 2: A → D
      const e2x = vD[0] - vA[0]
      const e2y = vD[1] - vA[1]
      const e2z = vD[2] - vA[2]

      // Face normal = cross product (e1 × e2)
      let nx = e1y * e2z - e1z * e2y
      let ny = e1z * e2x - e1x * e2z
      let nz = e1x * e2y - e1y * e2x

      // Normalize face normal
      ;[nx, ny, nz] = normalize(nx, ny, nz)

      // Accumulate this face normal to all four vertices
      normals[a][0] += nx
      normals[a][1] += ny
      normals[a][2] += nz

      normals[b][0] += nx
      normals[b][1] += ny
      normals[b][2] += nz

      normals[c][0] += nx
      normals[c][1] += ny
      normals[c][2] += nz

      normals[d][0] += nx
      normals[d][1] += ny
      normals[d][2] += nz
    }
  }

  // Normalize all accumulated vertex normals
  for (let i = 0; i < totalVerts; i++) {
    normals[i] = normalize(normals[i][0], normals[i][1], normals[i][2])
  }

  return normals
}

/**
 * Export mesh to Wavefront OBJ format.
 *
 * Creates a quad mesh with:
 * - Vertex list (v x y z)
 * - Face list (f v1 v2 v3 v4)
 *
 * Coordinate system:
 * - x: horizontal (cross-section)
 * - y: vertical (cross-section)
 * - z: axial (along horn)
 *
 * @param meshData - Generated mesh data
 * @returns OBJ format string
 */
export function exportToOBJ(meshData: MeshData | null): string {
  if (!meshData) return ''

  const { rings, numSlices } = meshData
  let obj = '# R-OSSE Waveguide Mesh\n'
  obj += '# Generated by Horn Designer\n'
  obj += '# https://github.com/taryune/horn-designer\n'
  obj += '# Exported with vertex normals for smooth shading\n\n'

  // Write vertices
  for (const { ring } of rings) {
    for (const [px, py, pz] of ring) {
      obj += `v ${px.toFixed(4)} ${py.toFixed(4)} ${pz.toFixed(4)}\n`
    }
  }

  obj += '\n'

  // Calculate and write vertex normals
  const normals = calculateVertexNormals(meshData)
  for (const [nx, ny, nz] of normals) {
    obj += `vn ${nx.toFixed(6)} ${ny.toFixed(6)} ${nz.toFixed(6)}\n`
  }

  obj += '\n'

  // Enable smooth shading
  obj += 's 1\n\n'

  // Write faces (quads connecting adjacent rings)
  // Format: f v1//vn1 v2//vn2 v3//vn3 v4//vn4
  const vertsPerRing = numSlices + 1
  for (let ri = 0; ri < rings.length - 1; ri++) {
    for (let si = 0; si < numSlices; si++) {
      // OBJ uses 1-based indexing
      const a = ri * vertsPerRing + si + 1
      const b = ri * vertsPerRing + si + 2
      const c = (ri + 1) * vertsPerRing + si + 2
      const d = (ri + 1) * vertsPerRing + si + 1
      obj += `f ${a}//${a} ${b}//${b} ${c}//${c} ${d}//${d}\n`
    }
  }

  return obj
}

/**
 * Download OBJ file to user's computer.
 *
 * @param meshData - Generated mesh data
 * @param filename - Output filename (default: "waveguide.obj")
 */
export function downloadOBJ(meshData: MeshData | null, filename: string = 'waveguide.obj'): void {
  const obj = exportToOBJ(meshData)
  if (!obj) return

  const blob = new Blob([obj], { type: 'text/plain;charset=utf-8;' })
  const link = document.createElement('a')
  const url = URL.createObjectURL(blob)

  link.setAttribute('href', url)
  link.setAttribute('download', filename)
  link.style.visibility = 'hidden'
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}
